# ViralKids - PadrÃµes de Desenvolvimento e Arquitetura

## ðŸ—ï¸ ARQUITETURA GERAL

### PrincÃ­pios Fundamentais
- **Clean Architecture**: SeparaÃ§Ã£o clara de responsabilidades em camadas
- **SOLID**: AplicaÃ§Ã£o rigorosa dos princÃ­pios SOLID
- **TDD**: Desenvolvimento orientado a testes
- **Arquitetura Limpa**: CÃ³digo limpo, testÃ¡vel e manutenÃ­vel

### Stack TecnolÃ³gica
- **Frontend**: React 19 + TypeScript + Vite
- **Estado**: Zustand (client state) + React Query (server state)
- **UI**: shadcn/ui + Tailwind CSS + Radix UI
- **Roteamento**: React Router DOM
- **FormulÃ¡rios**: React Hook Form + Zod
- **HTTP**: Axios com interceptors customizados
- **Build**: Vite com SWC
- **Linting**: ESLint + TypeScript ESLint

## ðŸ“ ESTRUTURA DE PASTAS

```
src/
â”œâ”€â”€ assets/                 # Recursos estÃ¡ticos (imagens, dados mock)
â”œâ”€â”€ components/             # Componentes da aplicaÃ§Ã£o
â”‚   â”œâ”€â”€ ui/                # Componentes base (shadcn/ui)
â”‚   â”œâ”€â”€ ecommerce/         # Componentes especÃ­ficos do e-commerce
â”‚   â””â”€â”€ [outros].tsx       # Componentes gerais
â”œâ”€â”€ features/              # Funcionalidades organizadas por domÃ­nio
â”‚   â”œâ”€â”€ auth/              # AutenticaÃ§Ã£o
â”‚   â”‚   â”œâ”€â”€ components/    # Componentes de auth
â”‚   â”‚   â”œâ”€â”€ context/       # Context de auth
â”‚   â”‚   â”œâ”€â”€ hooks/         # Hooks de auth
â”‚   â”‚   â””â”€â”€ types/         # Tipos de auth
â”‚   â”œâ”€â”€ chatbot/           # Sistema de chatbot
â”‚   â”œâ”€â”€ franchise/         # Sistema de franquias
â”‚   â””â”€â”€ suppliers/         # Sistema de fornecedores
â”œâ”€â”€ hooks/                 # Hooks customizados e wrappers
â”œâ”€â”€ lib/                   # UtilitÃ¡rios e configuraÃ§Ãµes
â”œâ”€â”€ pages/                 # PÃ¡ginas da aplicaÃ§Ã£o
â”‚   â”œâ”€â”€ Ecommerce/         # PÃ¡ginas do e-commerce
â”‚   â””â”€â”€ ProductDetail/     # PÃ¡ginas de detalhes
â”œâ”€â”€ providers/             # Providers da aplicaÃ§Ã£o
â”œâ”€â”€ router/                # ConfiguraÃ§Ã£o de rotas
â”œâ”€â”€ services/              # ServiÃ§os e APIs
â”‚   â”œâ”€â”€ api/               # Cliente HTTP e configuraÃ§Ãµes
â”‚   â”œâ”€â”€ auth/              # ServiÃ§os de autenticaÃ§Ã£o
â”‚   â”œâ”€â”€ chatbot/           # ServiÃ§os de chatbot
â”‚   â”œâ”€â”€ franchise/         # ServiÃ§os de franquia
â”‚   â”œâ”€â”€ products/          # ServiÃ§os de produtos
â”‚   â””â”€â”€ queries/           # React Query hooks
â”œâ”€â”€ stores/                # Stores Zustand
â”œâ”€â”€ types/                 # Tipos TypeScript globais
â””â”€â”€ main.tsx               # Ponto de entrada
```

## ðŸŽ¯ PADRÃ•ES DE COMPONENTES

### 1. Estrutura de Componente
```typescript
import React from 'react';
import { cn } from '@/lib/utils';

interface ComponentNameProps {
  title: string;
  description?: string;
  className?: string;
  children?: React.ReactNode;
}

export const ComponentName = ({ 
  title, 
  description, 
  className,
  children 
}: ComponentNameProps) => {
  return (
    <div className={cn('component-base', className)}>
      <h2 className="text-2xl font-semibold">{title}</h2>
      {description && (
        <p className="text-muted-foreground mt-2">{description}</p>
      )}
      {children}
    </div>
  );
};
```

### 2. Componente com Estado Integrado
```typescript
import React from 'react';
import { useProducts } from '@/hooks/useProducts';
import { useCartStore } from '@/stores/cart.store';
import { Button } from '@/components/ui/button';

interface ProductCardProps {
  product: Product;
}

export const ProductCard = ({ product }: ProductCardProps) => {
  // Server state (React Query)
  const { isLoading, error } = useProducts();
  
  // Client state (Zustand)
  const { addItem, isInCart } = useCartStore();

  const handleAddToCart = () => {
    addItem(product);
  };

  if (isLoading) return <div>Carregando...</div>;
  if (error) return <div>Erro: {error.message}</div>;

  return (
    <div className="product-card">
      <img src={product.image} alt={product.name} />
      <h3>{product.name}</h3>
      <p>{product.price}</p>
      <Button 
        onClick={handleAddToCart}
        disabled={isInCart(product.id)}
      >
        {isInCart(product.id) ? 'No Carrinho' : 'Adicionar ao Carrinho'}
      </Button>
    </div>
  );
};
```

## ðŸ”„ GERENCIAMENTO DE ESTADO

### SeparaÃ§Ã£o de Responsabilidades

#### **Zustand (Client State)**
```typescript
// âœ… Estado que pertence ao cliente
- Carrinho de compras
- Filtros de produtos
- PreferÃªncias do usuÃ¡rio
- Estado de UI (sidebar, modals, etc.)
- ConfiguraÃ§Ãµes de tema
- Estado de formulÃ¡rios
```

#### **React Query (Server State)**
```typescript
// âœ… Estado que vem do servidor
- Lista de produtos
- Dados do usuÃ¡rio
- HistÃ³rico de pedidos
- InformaÃ§Ãµes de estoque
- Dados de analytics
- ConfiguraÃ§Ãµes do sistema
```

### Store Pattern (Zustand)
```typescript
import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';

interface CartStore {
  cart: CartItem[];
  addItem: (product: Product) => void;
  removeItem: (productId: string) => void;
  clearCart: () => void;
  getCartTotal: () => number;
  getCartItemsCount: () => number;
  isInCart: (productId: string) => boolean;
}

export const useCartStore = create<CartStore>()(
  persist(
    (set, get) => ({
      cart: [],
      addItem: (product) => {
        set((state) => {
          const existingItem = state.cart.find(item => item.id === product.id);
          if (existingItem) {
            return {
              cart: state.cart.map(item =>
                item.id === product.id
                  ? { ...item, quantity: item.quantity + 1 }
                  : item
              )
            };
          }
          return {
            cart: [...state.cart, { ...product, quantity: 1 }]
          };
        });
      },
      removeItem: (productId) => {
        set((state) => ({
          cart: state.cart.filter(item => item.id !== productId)
        }));
      },
      clearCart: () => set({ cart: [] }),
      getCartTotal: () => {
        return get().cart.reduce((sum, item) => sum + (item.price * item.quantity), 0);
      },
      getCartItemsCount: () => {
        return get().cart.reduce((sum, item) => sum + item.quantity, 0);
      },
      isInCart: (productId) => {
        return get().cart.some(item => item.id === productId);
      }
    }),
    {
      name: 'viralkids-cart-storage',
      storage: createJSONStorage(() => localStorage),
      partialize: (state) => ({ cart: state.cart }),
    }
  )
);
```

### Hook Wrapper Pattern
```typescript
// hooks/useProducts.ts
import { useProducts as useProductsQuery } from '@/services/queries/products';
import { useCartStore } from '@/stores/cart.store';

export const useProducts = (filters?: ProductFilters) => {
  // Server state com React Query
  const queryResult = useProductsQuery(filters);
  
  // Client state com Zustand
  const { addItem, removeItem, isInCart } = useCartStore();

  return {
    // Server state
    products: queryResult.data,
    isLoading: queryResult.isLoading,
    error: queryResult.error,
    refetch: queryResult.refetch,
    
    // Client state (carrinho)
    addToCart: addItem,
    removeFromCart: removeItem,
    isInCart,
    
    // UtilitÃ¡rios
    hasProducts: !!queryResult.data && queryResult.data.length > 0,
    productsCount: queryResult.data?.length || 0,
  };
};
```

## ðŸŒ PADRÃ•ES DE API

### HTTP Client
```typescript
export class HttpClient {
  private client: AxiosInstance;

  constructor(config: HttpClientConfig = {}) {
    this.client = axios.create({
      baseURL: config.baseURL || API_CONFIG.BASE_URL,
      timeout: config.timeout || API_CONFIG.TIMEOUT,
      headers: { ...DEFAULT_HEADERS, ...config.headers },
    });

    this.setupInterceptors();
  }

  private setupInterceptors() {
    // Request interceptor
    this.client.interceptors.request.use(
      (config) => {
        const token = this.getAuthToken?.();
        if (token) {
          config.headers.Authorization = `Bearer ${token}`;
        }
        return config;
      },
      (error) => Promise.reject(error)
    );

    // Response interceptor
    this.client.interceptors.response.use(
      (response) => response,
      (error) => {
        if (error.response?.status === 401) {
          this.onAuthError?.();
        }
        return Promise.reject(error);
      }
    );
  }

  async get<T = any>(url: string, config?: AxiosRequestConfig): Promise<ApiResponse<T>> {
    try {
      const response = await this.client.get<ApiResponse<T>>(url, config);
      return response.data;
    } catch (error: any) {
      return this.handleError(error);
    }
  }
}
```

### Service Pattern
```typescript
export class ProductService {
  private httpClient: HttpClient;

  constructor(httpClient: HttpClient) {
    this.httpClient = httpClient;
  }

  async getAll(filters?: ProductFilters): Promise<Product[]> {
    const response = await this.httpClient.get<Product[]>(
      API_ENDPOINTS.PRODUCTS.LIST,
      { params: filters }
    );
    
    if (!response.success || !response.data) {
      throw new Error(response.error || 'Erro ao buscar produtos');
    }
    
    return response.data;
  }

  async getById(id: string): Promise<Product> {
    const response = await this.httpClient.get<Product>(
      API_ENDPOINTS.PRODUCTS.DETAIL(id)
    );
    
    if (!response.success || !response.data) {
      throw new Error(response.error || 'Produto nÃ£o encontrado');
    }
    
    return response.data;
  }
}
```

### React Query Integration
```typescript
// services/queries/products.ts
export const productKeys = {
  all: ['products'] as const,
  lists: () => [...productKeys.all, 'list'] as const,
  list: (filters: ProductFilters) => [...productKeys.lists(), filters] as const,
  details: () => [...productKeys.all, 'detail'] as const,
  detail: (id: string) => [...productKeys.details(), id] as const,
};

export const useProducts = (filters?: ProductFilters) => {
  return useQuery({
    queryKey: productKeys.list(filters || {}),
    queryFn: () => ProductService.getAll(filters),
    staleTime: 5 * 60 * 1000, // 5 minutos
    cacheTime: 10 * 60 * 1000, // 10 minutos
    refetchOnWindowFocus: false,
  });
};
```

## ðŸŽ¨ PADRÃ•ES DE ESTILIZAÃ‡ÃƒO

### Design System
```typescript
// tailwind.config.ts
export default {
  theme: {
    extend: {
      colors: {
        bronze: {
          DEFAULT: 'hsl(var(--bronze))',
          light: 'hsl(var(--bronze-light))',
          dark: 'hsl(var(--bronze-dark))'
        },
        copper: 'hsl(var(--copper))',
        gold: 'hsl(var(--gold))',
      },
      backgroundImage: {
        'gradient-bronze': 'var(--gradient-bronze)',
        'gradient-hero': 'var(--gradient-hero)',
      },
      boxShadow: {
        'bronze': 'var(--shadow-bronze)',
        'glow': 'var(--shadow-glow)',
      },
    }
  }
}
```

### Component Variants
```typescript
// components/ui/button.tsx
const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-md font-medium transition-colors",
  {
    variants: {
      variant: {
        default: "bg-gradient-bronze text-primary-foreground hover:shadow-bronze",
        outline: "border border-bronze bg-background hover:bg-bronze/10",
        hero: "bg-gradient-hero text-white hover:shadow-glow hover:scale-105",
        whatsapp: "bg-green-500 text-white hover:bg-green-600",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)
```

## ðŸ”§ CONFIGURAÃ‡Ã•ES CENTRALIZADAS

### Service Provider
```typescript
export class ServiceProvider {
  static auth = AuthService;
  static chatbot = ChatbotService;
  static franchise = FranchiseService;
  static product = ProductService;

  static initialize(): void {
    const { token } = AuthService.getAuthData();
    if (token) {
      httpClient.setAuthToken(token);
    }
  }

  static clearAllData(): void {
    ServiceProvider.auth.clearAuthData();
    ServiceProvider.chatbot.clearLocalData();
    ServiceProvider.franchise.clearLocalData();
    ServiceProvider.product.clearLocalData();
  }
}
```

### App Providers
```typescript
export const AppProviders: React.FC<AppProvidersProps> = ({ children }) => {
  return (
    <QueryProvider>
      <StoreProvider 
        fallback={<LoadingSpinner />}
      >
        {children}
      </StoreProvider>
    </QueryProvider>
  );
};
```

## ðŸ“ CONVENÃ‡Ã•ES DE NOMENCLATURA

### Arquivos e Pastas
```typescript
// Componentes: PascalCase
ProductCard.tsx
UserProfile.tsx
ShoppingCart.tsx

// Hooks: camelCase com prefixo 'use'
useProducts.ts
useCart.ts
useFilters.ts

// Stores: camelCase com sufixo '.store.ts'
cart.store.ts
filters.store.ts
user-preferences.store.ts

// Services: PascalCase com sufixo 'Service'
ProductService.ts
AuthService.ts
ChatbotService.ts

// Types: PascalCase
Product.ts
User.ts
CartItem.ts

// Constantes: UPPER_SNAKE_CASE
API_ENDPOINTS.ts
PRODUCT_CATEGORIES.ts
```

### VariÃ¡veis e FunÃ§Ãµes
```typescript
// VariÃ¡veis: camelCase
const productList = [];
const userData = {};
const isLoading = false;

// FunÃ§Ãµes: camelCase
const fetchProducts = () => {};
const handleSubmit = () => {};
const formatCurrency = () => {};

// Constantes: UPPER_SNAKE_CASE
const MAX_PRODUCTS = 10;
const API_BASE_URL = 'https://api.viralkids.com';
```

## ðŸ§ª PADRÃ•ES DE TESTE

### Teste de Componente
```typescript
import { render, screen, fireEvent } from '@testing-library/react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { ProductCard } from '@/components/ProductCard';

const queryClient = new QueryClient({
  defaultOptions: {
    queries: { retry: false },
    mutations: { retry: false },
  },
});

describe('ProductCard', () => {
  it('should render product information', () => {
    render(
      <QueryClientProvider client={queryClient}>
        <ProductCard product={mockProduct} />
      </QueryClientProvider>
    );
    
    expect(screen.getByText('Brinquedo Teste')).toBeInTheDocument();
    expect(screen.getByText('R$ 29,99')).toBeInTheDocument();
  });
});
```

## ðŸš€ PADRÃ•ES DE DEPLOY

### Build Configuration
```typescript
// vite.config.ts
export default defineConfig(({ mode }) => ({
  server: {
    host: "::",
    port: 8080,
  },
  plugins: [
    react(),
    mode === 'development' && componentTagger(),
  ].filter(Boolean),
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./src"),
    },
  },
}));
```

### Environment Variables
```bash
# .env.local
VITE_API_URL=https://api.viralkids.com
VITE_WHATSAPP_NUMBER=5511999999999
VITE_GOOGLE_ANALYTICS_ID=GA_MEASUREMENT_ID
```

## ðŸ“‹ CHECKLIST DE DESENVOLVIMENTO

### Antes de Commitar
- [ ] CÃ³digo segue os padrÃµes de nomenclatura
- [ ] Componentes sÃ£o tipados com TypeScript
- [ ] Estado Ã© gerenciado corretamente (Zustand vs React Query)
- [ ] Componentes seguem o padrÃ£o de estrutura definido
- [ ] Estilos usam o design system (Tailwind + shadcn/ui)
- [ ] ServiÃ§os seguem o padrÃ£o de API definido
- [ ] Hooks customizados sÃ£o reutilizÃ¡veis
- [ ] Error handling estÃ¡ implementado
- [ ] Loading states estÃ£o presentes
- [ ] CÃ³digo estÃ¡ limpo e bem documentado

### PadrÃµes de Commit
```bash
feat: adiciona funcionalidade de carrinho
fix: corrige bug na validaÃ§Ã£o de formulÃ¡rio
docs: atualiza documentaÃ§Ã£o da API
style: ajusta estilos do componente ProductCard
refactor: refatora hook useProducts
test: adiciona testes para ProductService
```

## ðŸ” DEBUGGING E MONITORAMENTO

### React DevTools
- Use para inspecionar componentes e estado
- Verifique re-renders desnecessÃ¡rios
- Monitore performance dos componentes

### React Query DevTools
```typescript
import { ReactQueryDevtools } from '@tanstack/react-query-devtools';

export const QueryProvider = ({ children }) => {
  return (
    <QueryClientProvider client={queryClient}>
      {children}
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  );
};
```

### Error Boundaries
```typescript
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    console.error('Error caught by boundary:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return <h1>Algo deu errado.</h1>;
    }
    return this.props.children;
  }
}
```

## ðŸ“š RECURSOS E FERRAMENTAS

### DocumentaÃ§Ã£o
- [React Documentation](https://react.dev/)
- [TypeScript Handbook](https://www.typescriptlang.org/docs/)
- [Tailwind CSS](https://tailwindcss.com/docs)
- [shadcn/ui](https://ui.shadcn.com/)
- [React Query Documentation](https://tanstack.com/query/latest)
- [Zustand Documentation](https://github.com/pmndrs/zustand)

### ExtensÃµes VS Code Recomendadas
- TypeScript Importer
- Tailwind CSS IntelliSense
- ES7+ React/Redux/React-Native snippets
- Auto Rename Tag
- Bracket Pair Colorizer
- GitLens

---

**Lembre-se**: Mantenha o cÃ³digo limpo, bem documentado e siga os padrÃµes estabelecidos para facilitar a manutenÃ§Ã£o e colaboraÃ§Ã£o. A separaÃ§Ã£o clara entre server state (React Query) e client state (Zustand) Ã© fundamental para a arquitetura do projeto.
